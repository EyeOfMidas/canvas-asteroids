<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style type="text/css">
        html,
        body {
            margin: 0;
            padding: 0;
        }

        canvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="asteroids"></canvas>
    <script src="./KeyCode.js"></script>
    <script src="./rAF.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", event => {
            init();
            animate();
        });

        window.addEventListener("resize", resize);
        window.addEventListener("keydown", onKeyDown);
        window.addEventListener("keyup", onKeyUp);

        var canvas;
        var context;
        var animId;
        var keys = [];

        var starsNear = [];
        var starsFar = [];

        var ship = {
            x: 0,
            y: 0,
            angle: -90,
            acceleration: { x: 0, y: 0 },
            velocity: { x: 0, y: 0 },
            width: 15,
            height: 20,
            rotationSpeed: 3,
            thrust: 0.2,
            bulletSpeed: 2,
            life: 3,
            score: 0,
        };

        var bullets = [];
        var shootDelay = 0;
        var asteroids = [];

        function resize() {
            let dpi = window.devicePixelRatio;
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            context.width = canvas.clientWidth / dpi;
            context.height = canvas.clientHeight / dpi;
        }

        function animate() {
            update();
            context.save();
            context.translate(0.5, 0.5);
            clearFrame(context);
            draw(context);
            context.restore();
            animId = requestAnimationFrame(animate, canvas);
        }

        function clearFrame(context) {
            context.fillStyle = "#000000";
            context.beginPath();
            context.rect(0, 0, canvas.width, canvas.height);
            context.fill();
        }

        function rand(min, max) {
            return max * Math.random() + min;
        }

        function doesCollide(mobile1, mobile2) {
            let distance = Math.sqrt(
                Math.pow(mobile1.x - mobile2.x, 2) +
                Math.pow(mobile1.y - mobile2.y, 2)
            )
            return mobile2.width / 2 >= distance - mobile1.width / 2;
        }

        function wrapAround(mobile) {
            if (mobile.x - mobile.width / 2 > canvas.width) { // too far right
                mobile.x = -mobile.width / 2;
            } else if (mobile.x + mobile.width / 2 <= 0) { // too far left
                mobile.x = canvas.width + mobile.width / 2;
            }

            if (mobile.y - mobile.height / 2 > canvas.height) { // too far down
                mobile.y = -mobile.height / 2;
            } else if (mobile.y + mobile.height / 2 <= 0) { // too far up
                mobile.y = canvas.height + mobile.height / 2;
            }
        }

        function getRandomPositionOnScreen() {
            let position = {};
            position.x = Math.floor(rand(0, canvas.width));
            position.y = Math.floor(rand(0, canvas.height));
            return position;
        }

        function getShipAnglePosition() {
            let shipAnglePosition = {};
            shipAnglePosition.x = Math.cos(ship.angle * (Math.PI / 180));
            shipAnglePosition.y = Math.sin(ship.angle * (Math.PI / 180));
            return shipAnglePosition;
        }

        function shipShape(context) {
            context.moveTo(ship.width / 2, -ship.height / 2);
            context.lineTo(0, ship.height / 2);
            context.lineTo(-ship.width / 2, -ship.height / 2);
            context.lineTo(ship.width / 2, -ship.height / 2);
        }

        function onKeyDown(event) {
            keys[event.keyCode] = true;
        }

        function onKeyUp(event) {
            keys[event.keyCode] = false;
        }

        function init() {
            canvas = document.getElementById("asteroids");
            context = canvas.getContext('2d');

            for (let i = 0; i < 256; i++) {
                keys[i] = false;
            }

            resize();

            //initialize the game objects here
            initStars();
            initShip();
            initAsteroids();
            initBullets();
        }

        function initStars() {
            starsNear = [];
            for (let i = 0; i < 50; i++) {
                let star = {};
                //This function picks a random coordinate within the bounds of the window
                let randomPosition = getRandomPositionOnScreen();
                star.x = randomPosition.x;
                star.y = randomPosition.y;
                //stars are circles, so their width and height are the same size
                star.width = rand(2, 4);
                star.height = star.width;
                starsNear.push(star);
            }

            starsFar = [];
            for (let i = 0; i < 300; i++) {
                let star = {};
                //This function picks a random coordinate within the bounds of the window
                let randomPosition = getRandomPositionOnScreen();
                star.x = randomPosition.x;
                star.y = randomPosition.y;
                //stars are circles, so their width and height are the same size
                star.width = rand(0.1, 2);
                star.height = star.width;
                starsFar.push(star);
            }
        }

        function updateStars() {
            for (let i = 0; i < starsNear.length; i++) {
                let star = starsNear[i];
                star.x += 0.15; //these stars a closer so they'll appear to move faster
                star.y += 0.15;
                //this function checks the position against the width/height and will wrap the objects around the screen.
                wrapAround(star);
            }

            for (let i = 0; i < starsFar.length; i++) {
                let star = starsFar[i];
                star.x += 0.05; //far-away stars will move much more slowly
                star.y += 0.05;
                wrapAround(star);
            }
        }

        function drawStars(context) {
            //this will be the color of all the stars
            context.fillStyle = "lightgray";
            for (let i = 0; i < starsNear.length; i++) {
                let star = starsNear[i];
                drawStar(context, star);

            }

            for (let i = 0; i < starsFar.length; i++) {
                let star = starsFar[i];
                drawStar(context, star);
            }
        }

        function drawStar(context, star) {
            //saving and restoring the context like this allows us to draw 0,0 centered images, which makes later transformations easier.
            context.save();
            //moves the canvas matrix to be centered on the star's screen position
            context.translate(star.x, star.y);
            //star drawing a vector shape
            context.beginPath();
            //plots out a cirle at 0,0: (x, y, radius, startAngle, endAngle)
            context.arc(0, 0, star.width / 2, 0, 2 * Math.PI);
            //draws the shape as a filled, lightgray circle
            context.fill();
            context.restore();
        }

        function initShip() {
            ship = {
                x: 0,
                y: 0,
                angle: -90,
                acceleration: { x: 0, y: 0 },
                velocity: { x: 0, y: 0 },
                width: 15,
                height: 20,
                rotationSpeed: 3,
                thrust: 0.2,
                bulletSpeed: 2,
                life: 3,
                score: 0,
            };

            ship.x = canvas.width / 2;
            ship.y = canvas.height / 2;
        }

        function updateShip() {
            ship.acceleration.x = 0;
            ship.acceleration.y = 0;

            if (keys[KeyCode.Up]) {
                // the getShipAnglePosition uses sin and cos to determine which way the ship is facing
                let position = getShipAnglePosition();

                //then we apply the maximum thrust value to those values to move the ship in that direction
                ship.acceleration.x = ship.thrust * position.x;
                ship.acceleration.y = ship.thrust * position.y;
            }

            if (keys[KeyCode.Left]) {
                ship.angle -= ship.rotationSpeed;
            }

            if (keys[KeyCode.Right]) {
                ship.angle += ship.rotationSpeed;
            }

            ship.velocity.x += ship.acceleration.x;
            ship.velocity.y += ship.acceleration.y;

            ship.x += ship.velocity.x;
            ship.y += ship.velocity.y;

            wrapAround(ship); // don't get lost in space!

            shootDelay--;
            if (keys[KeyCode.Space]) {
                if (shootDelay <= 0) {
                    addBullet();
                }
            }

            for (let j = 0; j < asteroids.length; j++) {
                let asteroid = asteroids[j];
                if (doesCollide(ship, asteroid)) {
                    hitShip(asteroid); // crash into this asteroid!
                    break;
                }
            }
        }

        function hitShip(asteroid) {
            ship.life--;

            if (ship.life <= 0) {
                alert(`You lose! Score: ${ship.score}`);
                init();
                return;
            }
            // move to a new random location (hopefully not somewhere an asteroid already is)
            ship.x = rand(0, canvas.width);
            ship.y = rand(0, canvas.height);
            // quit moving the ship
            ship.velocity.x = 0;
            ship.velocity.y = 0;
            ship.acceleration.x = 0;
            ship.acceleration.y = 0;
            // if the user is still holding up, clear that key
            keys[KeyCode.Up] = false;
        }

        function drawShip(context) {
            context.save();
            // the styleshere are css color values: try putting any HEX code, rgb() or color word here!
            context.strokeStyle = "red";
            context.fillStyle = "crimson";
            context.translate(ship.x, ship.y);
            context.rotate((ship.angle - 90) * (Math.PI / 180)); // this will rotate the entire context around the ship.position
            context.beginPath();
            shipShape(context); // this is just a convenient function for drawing a triangle
            context.fill();
            context.stroke();

            if (keys[KeyCode.Up]) {
                context.fillStyle = "orange";
                context.beginPath();
                context.moveTo(-ship.width / 4, -ship.height / 2);
                context.lineTo(ship.width / 4, -ship.height / 2);
                context.lineTo(0, -1.2 * ship.height); // fiddle with the -1.2 value here to change how big the flame is
                context.lineTo(-ship.width / 4, -ship.height / 2);
                context.fill();
            }

            context.restore();
        }

        function initAsteroids() {
            asteroids = [];
            for (let i = 0; i < 2; i++) {
                let position = getRandomPositionOnScreen();
                let velocity = { x: rand(-1, 2), y: rand(-1, 2) };
                let size = { width: 200, height: 200 };
                addAsteroid(position, velocity, size);
            }
        }

        function addAsteroid(position, velocity, size) {
            let asteroid = {};
            asteroid.x = position.x;
            asteroid.y = position.y;
            asteroid.width = size.width;
            asteroid.height = size.height;
            asteroid.velocity = {};
            asteroid.velocity.x = velocity.x;
            asteroid.velocity.y = velocity.y;
            asteroids.push(asteroid);
        }

        function updateAsteroids() {
            for (let i = 0; i < asteroids.length; i++) {
                let asteroid = asteroids[i];
                asteroid.x += asteroid.velocity.x;
                asteroid.y += asteroid.velocity.y;
                wrapAround(asteroid); // they should remain in the play field
            }
        }

        function drawAsteroids(context) {
            context.strokeStyle = "lightgray";
            context.fillStyle = "gray";
            for (let i = 0; i < asteroids.length; i++) {
                let asteroid = asteroids[i];
                context.save();
                context.translate(asteroid.x, asteroid.y);
                context.beginPath();
                context.arc(0, 0, asteroid.width / 2, 0, 2 * Math.PI);
                context.fill();
                context.stroke();
                context.restore();
            }
        }

        function initBullets() {
            bullets = [];
        }

        function updateBullets() {
            for (let i = 0; i < bullets.length; i++) {
                let bullet = bullets[i];
                bullet.x += bullet.velocity.x;
                bullet.y += bullet.velocity.y;
                wrapAround(bullet);

                // bullets age one each update loop
                bullet.lifespan--;

                // check each asteroid against this bullet
                for (let j = 0; j < asteroids.length; j++) {
                    let asteroid = asteroids[j];
                    if (doesCollide(bullet, asteroid)) {
                        hitAsteroid(bullet, asteroid);
                        break;
                    }
                }
            }

            // this returns an array of only bullets with valid lifespan values
            bullets = bullets.filter(bullet => bullet.lifespan > 0);
        }

        function hitAsteroid(bullet, asteroid) {
            bullet.lifespan = 0;
            let asteroidIndex = asteroids.indexOf(asteroid);
            asteroids.splice(asteroidIndex, 1);

            ship.score += asteroid.width * 10;

            if (asteroid.width <= 25) {
                if (asteroids.length == 0) {
                    alert(`You win! Score: ${ship.score}`);
                    init();
                }
                return;
            }

            // this size object is going to be half the size of the asteroid this bullet is colliding with
            let newSize = { width: asteroid.width / 2, height: asteroid.height / 2 };

            let velocityVariation = {};

            // a slightly random velocity, based on the parent asteroid
            velocityVariation.x = asteroid.velocity.x + rand(-1, 2);
            velocityVariation.y = asteroid.velocity.y + rand(-1, 2);
            addAsteroid(asteroid, velocityVariation, newSize);

            // a slightly different random velocity, so they drift apart
            velocityVariation.x = asteroid.velocity.x + rand(-1, 2);
            velocityVariation.y = asteroid.velocity.y + rand(-1, 2);
            addAsteroid(asteroid, velocityVariation, newSize);
        }

        function drawBullets(context) {
            context.fillStyle = "white";
            for (let i = 0; i < bullets.length; i++) {
                let bullet = bullets[i];
                context.save();
                context.translate(bullet.x, bullet.y);
                context.beginPath();
                context.arc(0, 0, bullet.width / 2, 0, 2 * Math.PI);
                context.fill();
                context.restore();
            }
        }

        function addBullet() {
            shootDelay = 15;
            let anglePosition = getShipAnglePosition();
            let bullet = {};
            //this will put the bullet's starting point at the tip of the rocket's nose
            bullet.x = ship.x + ((ship.height / 2) * anglePosition.x);
            bullet.y = ship.y + ((ship.height / 2) * anglePosition.y);
            //big chunky bullets
            bullet.width = 6;
            bullet.height = 6;
            bullet.velocity = {};
            // the bullets have their own initial velocity and direction,
            // but also inherit the ship's velocity too.
            bullet.velocity.x = ship.bulletSpeed * anglePosition.x + ship.velocity.x;
            bullet.velocity.y = ship.bulletSpeed * anglePosition.y + ship.velocity.y;
            bullet.lifespan = 75;
            bullets.push(bullet);
        }

        function drawUI(context) {
            context.font = "30px Arial";
            context.textAlign = "left";
            context.fillText(`Lives: ${ship.life}`, 10, 50);
            context.textAlign = "right";
            context.fillText(`Score: ${ship.score}`, canvas.width - 10, 50);
        }

        function update() {
            //update the game objects here
            updateStars();
            updateShip();
            updateAsteroids();
            updateBullets();
        }

        function draw(context) {
            //draw the game objects here
            drawStars(context);
            drawShip(context);
            drawAsteroids(context);
            drawBullets(context);
            drawUI(context);
        }
    </script>
</body>

</html>
